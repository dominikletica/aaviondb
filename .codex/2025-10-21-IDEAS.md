# Export Preset Evolution – Concept Notes (2025-10-21)

## Goal Recap
- Deliver **LLM-friendly exports** with deterministic, shallow JSON and clear guidance/policies.
- Manage presets centrally via CLI/REST (and später Studio UI) while retaining optional file import for Git-based workflows.
- Support dynamic entity selection, payload shaping, placeholder binding, and cross-project exports.
- Provide a robust default preset while keeping user-defined presets easy to duplicate and customise.
- Example use-case: provide detailed lore and canonical information/events for consistent story writing with an AI companion. LLMs should be able to treat these exports as canonical references and explore the data efficiently and deterministically without extensive prompting.

---

## Preferred Architecture (Single Strategy)
1. **Storage**
   - Presets live in the **system brain** under a dedicated namespace (e.g. `presets:<slug>`). They are stored as plain records (no per-preset version history) to avoid merge noise and improve UX.
   - A new `PresetAgent` system module exposes `preset list/show/create/update/delete/copy/import/export`.
   - Default preset (`presets:default`) is created during bootstrap via `PresetAgent::ensureDefaultPreset()` and marked read-only.
   - Optional import path: `preset import my-slice user/presets/my-slice.json` validates and persists a file-based preset.

2. **Validation**
   - Lightweight internal validator (no SchemaAgent dependency) ensures required fields, placeholder bindings, filter syntax, and output schema references. Validation runs on create/update/import.
   - On apply, missing placeholders trigger deterministic errors (`Preset placeholder "${entity}" missing`).

3. **Command Flow**
   - `export <project|*> [selectors] [--preset=slug] [--param key=value] [--usage=...] [--description=...]`
   - Preset can reference `${project}`, `${entity}`, `${param.topic}` etc. Placeholder resolver merges command args into preset configuration.
   - Preset removal is blocked for the default preset; users copy it (`preset copy default context-study`).

4. **Filter & Transform DSL**
   - DSL expressed as array of filter objects (`{ "type": "payload_numeric", "config": { ... } }`).
   - Filters evaluated by a shared **FilterEngine** service (standalone component). This engine can later power roadmap item #15 (reference/query syntax).
   - FilterEngine operations: `slug_equals`, `slug_in`, `parent_contains`, `payload_contains`, `payload_regex`, `payload_numeric`, `payload_missing`, `include_references`, `custom_placeholder`.
   - Payload filters reuse the same DSL with `scope: "payload"` to whitelist/blacklist fields.

5. **Schema Layout Options**
   - Preset references an output layout by ID (`layout: "context-flat-v1"`). Layout definitions shipped with PresetAgent (stored alongside default preset). Users can customise layouts by copying them.

6. **Roadmap Hooks**
   - Add roadmap item: *Evaluate relocating fieldsets/schemas into system brain for cross-brain reuse.*
   - Add roadmap item: *Configurable log verbosity check after core modules complete.*

---

## Candidate Export Layout Templates

## Default Export Layout Template – `context-unified-v2`

```json
{
  "meta": {
    "layout": "context-unified-v2",
    "preset": "${preset}",
    "generated_at": "${timestamp}",
    "scope": "${scope}",
    "description": "${description}",
    "action": "${action}"
  },
  "guide": {
    "usage": "${usage}",
    "notes": [
      "Each entity is self-contained and references others via '@project.slug' or '@project.slug.field'.",
      "Follow the 'refs' array to explore relationships without traversing nested trees.",
      "Active versions represent canon; include inactive versions intentionally when performing historical or what-if analysis.",
      "Use field references like '@project.slug.field.path' to resolve nested payload values deterministically."
    ]
  },
  "policies": {
    "load": "Treat 'active_version' as canonical unless selectors override.",
    "cache": {
      "ttl": ${policies.cache_ttl},
      "invalidate_on": ["hash", "commit"]
    },
    "references": {
      "include": true,
      "depth": ${policies.depth}
    }
  },
  "index": {
    "projects": ${index.projects},
    "entities": ${index.entities}
  },
  "entities": ${entities},
  "stats": {
    "projects": ${stats.projects},
    "entities": ${stats.entities},
    "versions": ${stats.versions}
  }
}
```

### Entity Object Structure
Each entry inside `entities` follows this structure:
```json
{
  "uid": "${entity.project}.${entity.slug}",
  "project": "${entity.project}",
  "slug": "${entity.slug}",
  "version": ${entity.version},
  "commit": "${entity.commit}",
  "active": ${entity.active},
  "parent": "${entity.parent}",
  "children": ${entity.children},
  "refs": ${entity.refs},
  "payload": ${entity.payload},
  "payload_versions": ${entity.payload_versions}
}
```
- `uid` is the canonical identifier used throughout the export (`@project.slug`).
- `parent` is either `null` or another `uid`.
- `children` is an array of `uid`s; empty array if the entity has no children.
- `refs` is an array of structured references `{ "type": "${ref.type}", "target": "@project.slug[.field]", "meta": ${ref.meta} }`.
- `payload` contains the selected fields from the active version (post whitelist/blacklist transforms).
- `payload_versions` is an array of historical version snapshots (only present when the export includes multiple versions).

### Index Example
```json
{
  "projects": [
    {
      "slug": "aurora7",
      "title": "Aurora Seven Initiative",
      "entities": ["aurora7.kael_mercer", "aurora7.alliance_treaty"]
    }
  ],
  "entities": [
    {
      "uid": "aurora7.kael_mercer",
      "slug": "kael_mercer",
      "project": "aurora7",
      "path": "entities[0]"
    }
  ]
}
```

### Notes
- Template is rendered via a restricted Mustache-style engine; placeholders resolve to JSON values (arrays/objects/scalars).
- `payload_versions` and `refs` are optional; omitted when empty to reduce noise.
- Additional layouts (e.g. JSONL, Markdown) can be maintained as alternative templates (`context-jsonl-v1`, `context-markdown-v1`), but `context-unified-v2` serves as the default baseline.

### Optional Enhancements (Deferred)
- External model suggestions included annotating refs with semantic relation types (e.g. friend, witness) or schema URIs; our flexible payloads already allow such data, so presets leave interpretation to fieldsets/payload values.
- Inline table annotations or entity-type tags can be derived from payload content or custom filters; keeping the export schema generic avoids hard-coding project-specific taxonomies.
- If needed later, presets/layouts can be extended with additional helper fields without breaking the base structure.
```
---

## Preset DSL & Syntax Ideas
- **Structure**:
```json
{
  "meta": {"description": "...", "usage": "...", "layout": "context-flat-v1"},
  "selection": {
    "projects": ["${project}"],
    "entities": [
      {"type": "slug_equals", "config": {"value": "${entity}"}},
      {"type": "parent_contains", "config": {"value": "characters/"}},
      {"type": "include_references", "config": {"depth": 2}}
    ],
    "payload_filters": [
      {"type": "payload_contains", "config": {"field": "tags", "values": ["pilot"]}},
      {"type": "payload_numeric", "config": {"field": "stats.importance", "op": ">=", "value": 0.75}}
    ]
  },
  "transform": {
    "whitelist": ["summary", "traits"],
    "blacklist": ["internalNotes"],
    "post": [{"type": "sort", "config": {"field": "slug"}}]
  },
  "policies": {
    "references": {"depth": 1},
    "cache": {"ttl": 3600}
  },
  "placeholders": ["project", "entity", "param.topic"],
  "params": {"topic": {"required": false, "default": ""}}
}
```
- **Copy workflow**: `preset copy default synopsis-flat` duplicates entire document and allows editing.
- **DSL host**: Filter rules processed by `FilterEngine` with clear type enums (e.g. `FilterType::SlugEquals`).
- **Error handling**: Missing placeholders or invalid ops raise deterministic `PresetValidationException` that surfaces through `CommandResponse::error`.

### FilterEngine as Shared Service
- Implement `FilterEngine::evaluate(SelectionContext $ctx, FilterSet $filters): bool`.
- Reuse for Reference/Query syntax (roadmap item #15) by exposing same DSL in future commands (`query`, `search`, etc.).
- Hosted in `system/Core/Filters`, injected into ExportAgent and future modules.


---

## Roadmap Notes (follow-up)
- **Configurable log verbosity** – already added earlier; ensure PresetAgent honours global log level settings once implemented.
- **Schemas/Fieldsets location review** – add roadmap item to explore moving `fieldsets` into the system brain for cross-brain reuse and single source of truth.

---

## Query & Resolver Concepts
- Support inline reference syntax inside payload text, e.g. `[ref @project.entity.field]` or `[query @project.entity (filter)]`.
- Introduce a `ResolverAgent` (future) that resolves markers during export/view operations and reverts them on save, keeping references dynamic.
- Filters/queries processed via a shared `FilterEngine` (DSL) with capabilities for depth-limited graph traversal (`include_references`), sorting, output shaping (plain, markdown/HTML list, hyperlink `<project/(parent_tree/)entity(#field)>`), loop protection, timeline filtering, relationship lookups etc.
- Export presets and ResolverAgent reuse the same FilterEngine to avoid logic duplication (aligns with roadmap item #15).
- Command parameters (`--var.key=value`) map to preset placeholders, enabling commands like `export storyverse scene --preset=history --var.timeline=3`. Presets expose available vars to Studio (`preset vars <slug>`).

---

## Next Steps
1. **Implement PresetAgent** in system modules: bootstrap default preset, handle CRUD/copy/import/export, enforce validation.
2. **Introduce FilterEngine** service to evaluate DSL and expose placeholder resolution helpers.
3. **Update ExportAgent** to:
   - Load presets from system brain via PresetAgent.
   - Accept command parameters (`--param key=value`).
   - Lift multi-project limitation when preset dictates selection.
   - Render exports via template IDs (using default templates if none specified).
4. **Documentation**: extend `docs/dev/partials/modules/export.md`, `docs/user/sections/export.md`, and add preset authoring guide.
5. **Testing hooks**: once PHPUnit harness exists, cover preset validation, FilterEngine, and template rendering.

*Document updated 2025-10-21 after review feedback.*
