# Export Preset Evolution – Concept Notes (2025-10-21)

## Goal Recap
- Deliver **LLM-friendly exports** with deterministic, shallow JSON and clear guidance/policies.
- Manage presets centrally via CLI/REST (and später Studio UI) while retaining optional file import for Git-based workflows.
- Support dynamic entity selection, payload shaping, placeholder binding, and cross-project exports.
- Provide a robust default preset while keeping user-defined presets easy to duplicate and customise.

---

## Preferred Architecture (Single Strategy)
1. **Storage**
   - Presets live in the **system brain** under a dedicated namespace (e.g. `presets:<slug>`). They are stored as plain records (no per-preset version history) to avoid merge noise and improve UX.
   - A new `PresetAgent` system module exposes `preset list/show/create/update/delete/copy/import/export`.
   - Default preset (`presets:default`) is created during bootstrap via `PresetAgent::ensureDefaultPreset()` and marked read-only.
   - Optional import path: `preset import my-slice user/presets/my-slice.json` validates and persists a file-based preset.

2. **Validation**
   - Lightweight internal validator (no SchemaAgent dependency) ensures required fields, placeholder bindings, filter syntax, and output schema references. Validation runs on create/update/import.
   - On apply, missing placeholders trigger deterministic errors (`Preset placeholder "${entity}" missing`).

3. **Command Flow**
   - `export <project|*> [selectors] [--preset=slug] [--param key=value] [--usage=...] [--description=...]`
   - Preset can reference `${project}`, `${entity}`, `${param.topic}` etc. Placeholder resolver merges command args into preset configuration.
   - Preset removal is blocked for the default preset; users copy it (`preset copy default context-study`).

4. **Filter & Transform DSL**
   - DSL expressed as array of filter objects (`{ "type": "payload_numeric", "config": { ... } }`).
   - Filters evaluated by a shared **FilterEngine** service (standalone component). This engine can later power roadmap item #15 (reference/query syntax).
   - FilterEngine operations: `slug_equals`, `slug_in`, `parent_contains`, `payload_contains`, `payload_regex`, `payload_numeric`, `payload_missing`, `include_references`, `custom_placeholder`.
   - Payload filters reuse the same DSL with `scope: "payload"` to whitelist/blacklist fields.

5. **Schema Layout Options**
   - Preset references an output layout by ID (`layout: "context-flat-v1"`). Layout definitions shipped with PresetAgent (stored alongside default preset). Users can customise layouts by copying them.

6. **Roadmap Hooks**
   - Add roadmap item: *Evaluate relocating fieldsets/schemas into system brain for cross-brain reuse.*
   - Add roadmap item: *Configurable log verbosity check after core modules complete.*

---

## Candidate Export Layout Templates
Below are three template drafts the preset loader can ship with (stored in system brain and/or as assets). All templates expose flat structures, include parent/child metadata, guidance, and policies.

### Template `context-flat-v1` (JSON)
```json
{
  "meta": {
    "generated_at": "${timestamp}",
    "scope": "${scope}",
    "description": "${description}",
    "action": "${action}"
  },
  "guide": {
    "usage": "${usage}",
    "notes": ["Prefer active versions", "Use parent/children hints for navigation"]
  },
  "policies": {
    "load": "Treat active_version as canonical unless selectors override.",
    "cache": "Invalidate when hash or commit changes.",
    "references": {"include": true, "depth": "${policies.depth}"}
  },
  "index": {
    "projects": "${index.projects}",
    "entities": "${index.entities}" 
  },
  "data": "${entities}",
  "stats": {
    "projects": "${stats.projects}",
    "entities": "${stats.entities}",
    "versions": "${stats.versions}"
  }
}
```
- `entities` rendered as array of flat entity objects: `{ "slug", "project", "version", "commit", "parent", "children", "tags", "payload" }`.
- Parent/child arrays contain slug references only to keep structure shallow.

### Template `context-tabular-v1` (JSONL)
```
# metadata
{"type":"meta","generated_at":"${timestamp}","scope":"${scope}"}
# guide entry
{"type":"guide","usage":"${usage}","policies":${policies.json}}
# entity rows (one per line)
{"type":"entity","project":"${entity.project}","slug":"${entity.slug}","version":"${entity.version}","parent":"${entity.parent}","children":${entity.children},"payload":${entity.payload}}
# stats
{"type":"stats","projects":${stats.projects},"entities":${stats.entities},"versions":${stats.versions}}
```
- JSON Lines format keeps files streamable, good for LLM chunking.

### Template `context-markdown-v1`
```
# ${description}

- Generated: ${timestamp}
- Scope: ${scope}

## Policies
${policies.markdown}

## Entities
${#entities}
### ${entity.project} / ${entity.slug}
- Version: ${entity.version} (commit ${entity.commit})
- Parent: ${entity.parent ?: "(root)"}
- Children: ${entity.children.join(", ") ?: "(none)"}
- Tags: ${entity.tags.join(", ")}

Payload:
```json
${entity.payload_pretty}
```
${/entities}

## Stats
- Projects: ${stats.projects}
- Entities: ${stats.entities}
- Versions: ${stats.versions}
```
- Markdown variant aimed at human review or summarisation tasks; JSON payload remains embedded for deterministic parsing.

Each template is referenced by ID in the preset (`layout: "context-flat-v1"`). ExportAgent renders by substituting placeholders with computed sections (using a restricted Mustache-style engine).

---

## Preset DSL & Syntax Ideas
- **Structure**:
```json
{
  "meta": {"description": "...", "usage": "...", "layout": "context-flat-v1"},
  "selection": {
    "projects": ["${project}"],
    "entities": [
      {"type": "slug_equals", "config": {"value": "${entity}"}},
      {"type": "parent_contains", "config": {"value": "characters/"}},
      {"type": "include_references", "config": {"depth": 2}}
    ],
    "payload_filters": [
      {"type": "payload_contains", "config": {"field": "tags", "values": ["pilot"]}},
      {"type": "payload_numeric", "config": {"field": "stats.importance", "op": ">=", "value": 0.75}}
    ]
  },
  "transform": {
    "whitelist": ["summary", "traits"],
    "blacklist": ["internalNotes"],
    "post": [{"type": "sort", "config": {"field": "slug"}}]
  },
  "policies": {
    "references": {"depth": 1},
    "cache": {"ttl": 3600}
  },
  "placeholders": ["project", "entity", "param.topic"],
  "params": {"topic": {"required": false, "default": ""}}
}
```
- **Copy workflow**: `preset copy default synopsis-flat` duplicates entire document and allows editing.
- **DSL host**: Filter rules processed by `FilterEngine` with clear type enums (e.g. `FilterType::SlugEquals`).
- **Error handling**: Missing placeholders or invalid ops raise deterministic `PresetValidationException` that surfaces through `CommandResponse::error`.

### FilterEngine as Shared Service
- Implement `FilterEngine::evaluate(SelectionContext $ctx, FilterSet $filters): bool`.
- Reuse for Reference/Query syntax (roadmap item #15) by exposing same DSL in future commands (`query`, `search`, etc.).
- Hosted in `system/Core/Filters`, injected into ExportAgent and future modules.


---

## Roadmap Notes (follow-up)
- **Configurable log verbosity** – already added earlier; ensure PresetAgent honours global log level settings once implemented.
- **Schemas/Fieldsets location review** – add roadmap item to explore moving `fieldsets` into the system brain for cross-brain reuse and single source of truth.

---

## Query & Resolver Concepts
- Support inline reference syntax inside payload text, e.g. `[ref @project.entity.field]` or `[query @project.entity (filter)]`.
- Introduce a `ResolverAgent` (future) that resolves markers during export/view operations and reverts them on save, keeping references dynamic.
- Filters/queries processed via shared `FilterEngine` (DSL) with capabilities for depth-limited graph traversal (`include_references`), sorting, output-shaping (plain, markdown/html list, hyperlink </project/(parent_tree/)entity(#field)>), loop-protection, timeline filtering, relationship lookups etc.
- Export presets and ResolverAgent reuse the same FilterEngine to avoid logic duplication (aligns with roadmap item #15).
- Command parameters (`--var.key=value`) map to preset placeholders, enabling commands like `export storyverse scene --preset=history --var.timeline=3`. Preset should expose available Vars for usage in UI-Tools (e.g. `preset vars <slug>`).



## Next Steps
1. **Implement PresetAgent** in system modules: bootstrap default preset, handle CRUD/copy/import/export, enforce validation.
2. **Introduce FilterEngine** service to evaluate DSL and expose placeholder resolution helpers.
3. **Update ExportAgent** to:
   - Load presets from system brain via PresetAgent.
   - Accept command parameters (`--param key=value`).
   - Lift multi-project limitation when preset dictates selection.
   - Render exports via template IDs (using default templates if none specified).
4. **Documentation**: extend `docs/dev/partials/modules/export.md`, `docs/user/sections/export.md`, and add preset authoring guide.
5. **Testing hooks**: once PHPUnit harness exists, cover preset validation, FilterEngine, and template rendering.

*Document updated 2025-10-21 after review feedback.*
